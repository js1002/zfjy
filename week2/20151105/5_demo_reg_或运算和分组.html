<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>无标题文档</title>
</head>

<body>
</body>
</html>
<script>
    var str = "1234567890abc0987654321";
    var str2 = "234";
    var str3 = "23455555";
    var str4 = "2345678abcd";
    var str5 = "abc";
    var reg = /2345*/;
    reg = /(2345)*/;//这是一个无效的正则，什么都可匹配，原因在于让2345这个字符串，可以出现，也可以不出现;如果2345不出现，就相当一个空模式和一个字符串去匹配了，永远为true（任何一个字符串，都会被认为包括空字符串）
    reg1 = /2345+/;
    reg2 = /(2345)+/;//如果能被reg1验证成功，则一定也可以被reg2验证成功。如果只是为了去验证字符串，这两个应该一样，如果是捕获则不一样了。
    //reg2=/(?:2345)+/;如果在括号里的开始部分加上?:,表示匹配不捕获，就是说不让括号里的这一部分正则以子正则的方式出现
    //括号的意义：表示优先级，表示这是一个子正则，就是分组的概念
    var str1 = "ab1234555555";//捕获的时候，对于这个字符串，以上两个正则捕获的内容不一样。
    var str2 = "xy2234523452345cd";//这个不一样了
    //alert(reg.test(str5))
    //alert(str1.match(reg1));
    //alert(str1.match(reg2));//只要去和reg2去匹配和捕获，结果是两个。子正则的原因
    //alert(str2.match(reg1));
    //alert(str2.match(reg2));
    //观察以上结果有何不同，为什么？


    ////括号的意义：表示优先级，表示这是一个子正则，就是分组的概念
    var str1 = "I am an English";
    var str2 = "I am a Chinese";
    var reg = /I am (a|an) (Chinese|Japanese|French|German|English)/;

    //alert(str1.match(reg));

    //alert(str2.match(reg));


    var reg = /[abcdefg]/;
    reg = /[0-9]/;//-表示连续按顺序出现在ASCII表中的字符
    //-什么时候才表示前后的连字符呢？它前后的字符必须要在ASCII码里是按顺序出现的
    //reg=/[9-0]/
    reg = /[A-Za-z]/;
    reg = /[a-z]/i;//i是忽略大小定\w
    reg = /[A-z]/;
    reg = /[\u0061-\u007a]/;
    reg = /[0-100]/;//这不表示0到100，因为正则是处理字符串的，不认识数字100
    reg = /[\w]/;//方括号里可以出现元字符，但不能出现单字符的元字符
    reg = /[.\s]/;//这个只表示.本身和不可见字符
    reg = /[.+?]/;//这里的.,+,*，?都已经不再是元字符了，而是这个字符本身
    reg = /[a-z-]/;//想匹配从a到z再加上-,只要-不出现在连续的两个字符的中间，则会不会被认为是连字符。把-放在[]的开始或结尾最为稳妥

    /////以下是分组和分组的引用

    var reg = /^(\d)\d\1$/;//1、表示只能匹配三位的纯数字字符串。2、\1表示第一个括号中匹配到了什么内容，则这儿就要一定出现什么内容，也就是\1的位置上和第一个分组的位置的内容要完全相同
    //这就是分组的引用。分组引用有一个前提，就是不能在分组里加?:

    var str1 = "121";//323,333,414,121,717,
    reg = /(\d)(\d)\2\1/;//可以匹配1221,4554,1001,
    reg = /(\w)(\w)\2\1/;
    reg = /^(\d)(\d)\1\1\1$/;//只有第二个位置上的数字可以不一样，其它位置上的数字必须都一样

    //验证一个字符是不是完全重复的数字：77777777777777777，888888888888，9999

    reg = /\d+/;//这个只表示连续出现的数字，但数字未必相同
    reg = /^(\d)\1+$/;//使用分组引用，使第二个到第n个位置上出现的内容和第一个位置上的内容（分组中的）相同
    reg = /^(\d)+\1$/;//这个正则倒底是表示首尾相同呢还是最后两位相同呢？表示最后两位相同，为什么呢？
    //这个正则可以验证"12345677",但是不能验证"12345671";


    //我们如果知道或得到分组（子正则）捕获到的内容呢？
    reg.test("12345677");
    //alert(RegExp.$1);//正则类上的$1-$99这个属性
    str = "1234567";
    ///(\d)+/;
    ///\d+/;
    reg = /^(\d)\1+$/;


    //正向预查和负向预查，带条件的正则
    var reg = /\d+(?=zhufeng$)/;//(?=zhufeng$)是这个正则的条件，它不参加捕获。当字符串满足了括号里的?=后边的这个条件的描述的时候，才去捕获\d+的内容。
    //当满足这个条件成立，是正向预查。

    //var str="abc34849zhufengpeixun";//这个就不满足，因为zhufeng不是出现在结尾
    var str = "abc34849zhufeng";//这个就成立
    //alert(reg.exec(str));

    //负向预查：如果是当这个条件不成立时去捕获\d+的内容，叫负向预查
    var reg = /\d+(?!zhufeng$)/;
    var str = "abc34849zhufeng";//上面的正则貌似不会通过这个字符串，因为它的右边结尾确实是zhufeng，但是也可以看成是9zhufeng，所以，下边会弹出3484来。
    alert(reg.exec(str));
    //如果把正则修改一下，改成捕获固定长度数字就好了

    reg = /\d{5}(?!zhufeng$)/;
    alert(reg.exec(str));//这样就不成立了。
</script>
